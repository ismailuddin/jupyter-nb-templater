#!/usr/bin/env python

import json
import argparse
import datetime
import sys
import os

desc = """\
A tool to generate a Python script that can generate a Jupyter
notebook programmatically, using an existing Jupyter notebook as
a template."""

parser = argparse.ArgumentParser(description=desc)
parser.add_argument('-f', '--filename', help='Filename of Jupyter noteboo to use as template')
parser.add_argument('-o', '--output', help='Filename of output script')
parser.add_argument('-n', '--nboutput', help='(Optional) Filename of Jupyter notebook generated by output script. If not set, defaults to input filename appended by `_`')

args = parser.parse_args()

if len(sys.argv) == 1:
    parser.print_help()
    sys.exit()

filename = args.filename

# Read in Jupyter notebook template file
with open(file=filename, mode='r', encoding='utf-8') as file:
    ipynb = json.load(file)

nb_cells = []
output_str = ""

# Parse cells in Jupyter notebook template
for cell in ipynb['cells']:
    cell_type = cell['cell_type']
    source = cell['source']
    old_metadata = cell['metadata']
    metadata = {}
    # it is not necessary to add all metadata
    # metadata keys can be added here if needed
    # add tags
    if 'tags' in old_metadata:
        tags = old_metadata['tags']
        if tags:
            metadata['tags'] = tags
    nb_cells.append([cell_type, source, metadata])

now = datetime.datetime.now()
datetime_now = now.strftime("%Y-%m-%d %H:%M %Z")

output_header="""\
# -*- coding: utf-8 -*-
# `nb_templater` generated Python script
# Generated from .ipynb template: {}
# www.github.com/ismailuddin/jupyter-nb-templater/
# Generated on: {}

import nbformat as nbf 
import sys
nb = nbf.v4.new_notebook() \n\n""".format(args.filename, datetime_now)

cell_template_string = """\
cell_{0}=r\"\"\"
{1}
\"\"\".strip()\n
"""

output_str += output_header

# Generate string variable declarations of cell contents
for i, cell in enumerate(nb_cells):
    _source = ''.join(cell[1])
    _cell = cell_template_string.format(i, _source)
    output_str += _cell


nb_cells_generator_str = """\
nb['cells'] = [
{}
]
"""

mdown_cell_str = """\
    nbf.v4.new_markdown_cell({})"""

code_cell_str = """\
    nbf.v4.new_code_cell({})"""

_list_of_cells = []

# Generate Python list of cells
for i, cell in enumerate(nb_cells):
    if cell[0] == 'markdown':
        _cell = mdown_cell_str.format("cell_{}".format(i))
        _list_of_cells.append(_cell)
    elif cell[0] == 'code':
        if cell[2]:
            _cell = code_cell_str.format("source=cell_{},metadata={}".format(i,cell[2]))
        else:
            _cell = code_cell_str.format("cell_{}".format(i))
        _list_of_cells.append(_cell)

list_of_cells = ',\n'.join(_list_of_cells)

nb_cells_generator = nb_cells_generator_str.format(list_of_cells)

output_str += nb_cells_generator

# add metadata as if it was created with jupyter notebook
# missing metadata may cause error when working with some CLI processes
nb_metadata_generator_str = """
nb['metadata'] = {}
"""
old_nb_metadata = ipynb['metadata']
nb_metadata = {}
# add kernelspec if any
if 'kernelspec' in old_nb_metadata:
    kernelspec = old_nb_metadata['kernelspec']
    if kernelspec:
        nb_metadata['kernelspec'] = kernelspec

if nb_metadata:
    nb_metadata_generator = nb_metadata_generator_str.format(nb_metadata)
    output_str += nb_metadata_generator

if args.nboutput:
    nb_output_name = args.nboutput 
else:
    nb_output_name = os.path.realpath(args.filename)
    nb_output_base_name = "_" + os.path.basename(nb_output_name)
    nb_output_dir = os.path.dirname(nb_output_name)
    nb_output_name = os.path.join(nb_output_dir,nb_output_base_name)

write_nb = """\n
nbf.write(nb, r'{0}')
print(r"Jupyter notebook {0} successfully generated.")
""".format(nb_output_name)

output_str += write_nb

# Output Python script file
with open(file=args.output, mode='w', encoding='utf-8') as output:
    output.write(output_str)

print("Python script {} generated sucessfully.".format(args.output))


